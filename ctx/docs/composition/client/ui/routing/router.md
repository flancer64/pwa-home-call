# Принципы работы и механика Router

Path: `./ctx/docs/composition/client/ui/routing/router.md`

## Базовый принцип

Router не содержит списка маршрутов и не зависит от конкретных экранов. Он получает через DI:

- `routeConfig: { [name: string]: { template: string, controllerFactory: string } }` — описание шаблонов и контроллеров, доступных в текущей композиции;
- `defaultParams: { [name: string]: Record<string, unknown> }` — значения параметров по умолчанию, которые дополняют те, что извлекаются из URL или передаются при навигации.
 - `registerRoute(descriptor)` и `setDefaultParams(name, params)` — API конфигурационного модуля, позволяющее Flow/Bootstrапу добавлять маршруты и подменять параметры в реальном времени.

Router может выполнять маршрутизацию хотя бы для одного элемента `routeConfig`, но сам не объявляет ни имён маршрутов, ни путей к шаблонам и контроллерам. Конкретные определения маршрутов находятся в `routes.md` и в DI-конфигурации композиции.

## Формат конфигурации маршрута

Каждая запись `routeConfig[name]` должна включать:

- `template` — идентификатор шаблона или путь, который Router передаёт TemplatesLoader;
- `controllerFactory` — DI-фабрика, создающая контроллер при каждой навигации (см. ниже).

Опциональные метаданные позволяют Router адаптировать разбор hash и выбор маршрутов к конкретным требованиям:

- `segmentParams` — упорядоченный список имён параметров, значения которых привязываются к дополнительным сегментам hash, и которые Router извлекает при `resolve` и вставляет при `navigate`.
- `initial` — если `true`, Router использует этот маршрут при отсутствии hash; значение должно быть уникальным.
- `fallback` — при `true` маршрут становится целью перехода в случае неизвестного hash.

Дополнительно Router использует `defaultParams[name]`, чтобы объединить значения по умолчанию и параметры из hash, прежде чем передать их контроллеру. Router не хранит параметры внутри себя и не подменяет значения, поступающие из локальных источников.

## Конфигурационный API

- `registerRoute(descriptor)` — конфигурационный модуль вызывает это у Router/или регистрирует через DI, чтобы добавить шаблон/контроллер/метаданные для нового маршрута.
- `setDefaultParams(name, params)` — Flow или другой клиент подставляет реальные обработчики и значения по умолчанию для маршрутов, включая `home`, `call`, `end` и `not-found`.
- Router подписывается на обновления конфигурации, чтобы пересобирать `routeConfig`/`defaultParams` при добавлении новых записей.

## Ответственности Router

1. **Разбор hash-части URL** (`resolve`) — выделение имени маршрута и параметров, допустимых для данного ключа конфигурации.
2. **Выбор записи из `routeConfig`** — сопоставление имени маршрута с доступными описаниями; при отсутствии соответствия переключение на объявленный fallback-маршрут, описанный в конфигурации маршрутов. Router гарантирует, что `not-found` или другой fallback получает `onReturn`, который возвращает браузер к `/` без уклонов.
3. **Загрузка шаблона** — передача выбранного `template` в TemplatesLoader и ожидание результата.
4. **Создание контроллера через фабрику** — вызов `controllerFactory` с аргументами `{ params, dependencies }` и получение нового экземпляра контроллера для текущего экрана.
5. **Монтирование и размонтирование** — очистка предыдущего экрана, монтирование нового шаблона, передача контроллеру контейнера и параметров, а затем запуск жизненного цикла (`mount`, при необходимости `unmount`).
6. **Обновление контекста** — поддержание одного активного экрана и мониторинг хеш-изменений (`hashchange`).

Router не хранит экземпляры контроллеров между вызовами: каждый переход инициирует вызов `controllerFactory`, а возвращённый экземпляр используется только в пределах текущего экрана.

## Контроллеры через фабрики

`controllerFactory` — это DI-фабрика, обеспечивающая Router новым контроллером при каждом переходе. Она получает параметры маршрута и необходимые зависимости и возвращает объект с методами `mount`, `unmount` и, опционально, `update` или другими, описанными в конфигурации. Router не принимает готовые экземпляры контроллеров и не повторно использует их между экранами.

## Интерфейс маршрутизатора

- `init()` — подключает обработчики `hashchange`, вызывает `resolve` и `navigate` для текущего hash.
- `resolve(hash: string)` — преобразует hash в `{ name, params }`, учитывая шаблон маршрута и `defaultParams`.
- `navigate(name: string, overrides?: Record<string, unknown>)` — инициирует переход, если запись найдена, или переходит на fallback-маршрут.
- `mountCurrentRoute()` — загружает шаблон и контроллер, передаёт параметры, вызывает lifecycle-методы.
- `unmountCurrentRoute()` — размонтирует текущий экран и освобождает ресурсы перед новым переходом.

Таким образом Router реализует стабильную механическую основу навигации без жёстких привязок к экранной карте и позволяет добавлять новые представления только через конфигурацию маршрутов.
