# Правила модульного тестирования Web-компонентов (ctx/rules/web/testing.md)

## Инвариант уровня (обязателен для всех тестов)

**Тесты веб-приложения Приложение не имеют права использовать статические импорты проектных модулей.  
Все модули веб-приложения загружаются только через DI-контейнер `@teqfw/di`, создаваемый функцией  
`createWebContainer()` из `test/web/helper.mjs`.**

Исключение: статические импорты разрешены только для стандартных тестовых библиотек и тестовых хэлперов.

---

## Назначение

Документ определяет правила модульного тестирования **браузерной части** проекта **Приложение**.
Он уточняет рамочные принципы из `ctx/rules/arch/testing.md`, описывая подход к изоляции, организации и
выполнению тестов для фронтенд-компонентов, исполняемых в среде браузера.

---

## Область применения

Правила распространяются на тесты, проверяющие работу клиентской логики приложения, включая:

- ядро (`HomeCall_Web_Core_*`);
- пользовательский интерфейс (`HomeCall_Web_Ui_*`);
- управление медиа и сетью (`HomeCall_Web_Media_*`, `HomeCall_Web_Net_*`);
- вспомогательные компоненты (`HomeCall_Web_Pwa_*`, `HomeCall_Web_Shared_*`).

Все тесты выполняются в Node.js, где браузерная среда эмулируется с помощью мок-объектов (`window`,
`document`, `navigator`, `MediaStream` и др.).  
Задача тестов — проверить корректность публичного поведения модулей без обращения к реальному DOM и
устройствам.

---

## Критическое архитектурное правило

Этот раздел имеет **высший приоритет** и обязателен для выполнения Codex-агентом.

### 1. Запрет статических импортов проектных модулей

Запрещено:

```js
import Toast from "../../../../web/app/Ui/Toast.mjs"; // ❌ запрещено
import { ScreenEnter } from "../../../../web/app/Ui/Enter.mjs"; // ❌ запрещено
```

Разрешено:

- стандартные библиотеки (`node:test`, `node:assert/strict`, `sinon`, `timers/promises`);
- тестовые инструменты (`test/web/helper.mjs`, фикстуры, mock-объекты);
- вспомогательные тестовые файлы (`mockSignal.js`, `fakeMedia.js`).

### 2. Единственный источник проектных объектов — DI-контейнер

Правильно:

```js
import { createWebContainer } from "../helper.mjs";

const di = await createWebContainer();
const toast = await di.get("HomeCall_Web_Ui_Toast$");
const app = await di.get("HomeCall_Web_Core_App$");
```

Это обеспечивает:

- корректную инициализацию контуров;
- возможность подмены зависимостей;
- единообразие среды исполнения;
- соответствие архитектуре TeqFW.

### 3. Любой тест с прямым import из каталога `web/` является ошибкой архитектуры

Codex-агент обязан переписать такой тест немедленно.

---

## Структура каталогов

```text
project-root/
├── web/
│   └── app/
│       ├── Core/
│       ├── Media/
│       ├── Ui/
│       └── Pwa/
└── test/
    └── web/
        ├── helper.mjs
        ├── app/
        │   ├── Core/
        │   │   ├── App.test.mjs
        │   │   └── UiController.test.mjs
        │   ├── Media/
        │   │   └── Manager.test.mjs
        │   ├── Pwa/
        │   │   └── CacheCleaner.test.mjs
        │   └── Ui/
        │       └── Enter.test.mjs
```

Каждый модуль из `web/app/...` имеет зеркальный тест в `test/web/app/...`.

---

## Инициализация контейнера

Для создания DI-контейнера используется общий _helper_ `test/web/helper.mjs`:

```js
import { createWebContainer } from "../helper.mjs";
const container = await createWebContainer();
const app = await container.get("HomeCall_Web_Core_App$");
```

Особенности:

- загрузка контейнера через `@teqfw/di`;
- namespace веб-приложения регистрируется как `HomeCall_Web_`;
- каждый тест использует новый контейнер;
- мок-объекты регистрируются через `container.register()`.

---

## Использование контейнера и тестового хэлпера

- Каждый тест обязан создавать контейнер через `createWebContainer()`.
- Все DI-компоненты получаются только через `container.get()`.

Пример:

```js
import { createWebContainer } from "../helper.mjs";

const di = await createWebContainer();
const storage = await di.get("HomeCall_Web_Infra_Storage$");
```

---

## Организация тестов

- Тестирование исключительно по **публичному API**.

- Браузерная среда эмулируется stub-объектами:

  - `window`, `document`, `navigator`;
  - `MediaStream`, `FormData`;
  - DOM-элементы c `addEventListener`, `classList`, `textContent`.

- Сценарии включают:

  - клики и submit;
  - обновление DOM;
  - mock-медиа (`getUserMedia`);
  - mock-WebSocket (`SignalClient`);
  - работу PWA (`CacheCleaner`, `ServiceWorkerManager`).

- Каждый тест полностью изолирован:

  - свой контейнер,
  - очистка глобальных объектов в `finally`.

---

## Инструменты

- Среда: **Node.js**
- Библиотеки: встроенные `node:test`, `node:assert/strict`
- Запуск:

```bash
npm run test:web
```

- Тесты должны быть идемпотентны.
- Логи и названия тестов — на английском.
- Разрешены stub-функции для времени (`setTimeout`, `setInterval`).

---

## Контроль согласованности

1. Каждый публичный модуль должен иметь зеркальный тест.
2. Изменения в логике требуют обновления тестов.
3. Ошибки при `npm run test:web` считаются несогласованностью веб-контекста.
4. Тесты обязаны проверять:

   - корректность инициализации DI-контейнера;
   - поведение UI и экранов;
   - работу медиа и сети;
   - отсутствие утечек состояния.

5. **Если тест содержит статический импорт модулей из `web/`, это нарушение инварианта и такой тест должен быть переписан.**

---

## Принципы проектирования тестов

- **Изоляция** — новый контейнер и окружение на каждый тест.
- **Контрактность** — тестируется публичный API.
- **Репрезентативность** — сценарии моделируют реальные действия.
- **Идемпотентность** — повторный запуск не меняет состояние.
- **Читаемость** — тест читается как спецификация.

---

## Ссылки

- `ctx/rules/arch/testing.md`
- `ctx/rules/node/testing.md`
- `ctx/rules/arch/di.md`

---

## Итог

Документ фиксирует строгие и однозначные правила тестирования веб-компонентов Приложение,
где **DI-контейнер — единственный источник проектных модулей**,
а статические импорты запрещены как нарушение архитектуры.
Эти требования обеспечивают полную воспроизводимость, изоляцию и соответствие модели TeqFW.
