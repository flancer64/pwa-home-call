# Архитектура приложения Связист (обзор)

## Назначение

Связист — Node.js-приложение, созданное по философии **TeqFW** с использованием контейнера `@teqfw/di`. Оно предоставляет прогрессивное веб-приложение (PWA) для семейной видеосвязи.

> **Согласованность с продуктовой моделью:** `ctx/product/overview.md`, `ctx/product/capabilities/connection.md` и `ctx/product/capabilities/link-sharing.md` обещают одно окно связи с состояниями `ready → waiting → active`, в котором ссылка создаётся внутри текущего сеанса. Сейчас код (`web/app/Ui/Flow.mjs`, `web/app/Ui/Controller.mjs`, `web/app/State/Machine.mjs`) по-прежнему управляет экранами `home`, `invite`, `call`, `end`, поэтому документ описывает именно этот путь; см. план `ctx/agent/plan/2025/11/20251129-rules-implementation-fixes.md` для будущего переписывания в сторону inline-состояний.

## Компоненты проекта

1. **Node.js-бэкенд** — единый процесс с HTTP-слоем `@flancer32/teq-web`, сервисами и маршрутизацией, управляемый контейнером `@teqfw/di`.
2. **Файловое хранилище** — JSON-конфигурации и данные, обслуживаемые без внешней СУБД.
3. **Фронтенд PWA** — модульный монолит, собранный как самостоятельный SPA и отдаваемый Apache из `./web/`; его внутренняя структура описается в `ctx/rules/arch/front.md` и сопровождающих `ctx/rules/web/*` документах.
4. **Окружения и развертывание** — конфигурация Apache и Node.js (`ctx/rules/arch/env/*.md`), файлы `.env`, сервис-воркер, обновления версий и статическая поставка PWA.

## Принципы для частей

- **Backend и Frontend** — оба слоя управляются DI-контейнером `@teqfw/di`, который обеспечивает регистрации сервисов, оркестрации и позднее связывание как в браузерной сборке, так и в тестах или агентах.
- **Бэкенд** концентрирует HTTP, API и сигналинг; его API предоставляет frontend-части инфраструктуру сигналов, каналов и данных.
- **Фронтенд** описан на карте `ctx/rules/arch/front.md`: High-level зоны, управление потоками через DI-коллбэки, коллбэки внутри контуров и позднее связывание через контейнер. Детали реализации каждого контура — в `ctx/rules/web/{core,env,ui,media,rtc,net,shared}.md`.
- **Окружения (Env, deployment)** — параметры описаны в `ctx/rules/arch/env/*.md`, включая конфигурацию TLS, сервис-воркер, `.env` и командную строку.
- **LLM- и Codex-агенты** собирают среду посредством регистрации зависимостей в DI и запускают либо браузерную сборку, либо headless-тесты, сохраняя единый источник истины.

## Связь с продуктовой моделью

- Стратегия `ctx/product/overview.md` обязывает фронтенд остаться в одном окне и управлять состояниями `ready`, `waiting`, `active`, пока backend поддерживает только технический `sessionId`. `arch/state.md` описывает текущую реализацию на `home → invite → call → end`, но название состояний будет скорректировано, когда код перейдёт на новую модель (см. `ctx/agent/plan/2025/11/20251129-rules-implementation-fixes.md`).
- `ctx/product/capabilities/connection.md` и `ctx/product/capabilities/link-sharing.md` определяют, что ссылка создаётся в контексте уже работающего сеанса и остаётся привязанной к нему. Это объясняет, почему `arch/rtc/*` и `web/infra/ws.md` держат WebRTC-сигналинг и `sessionId` в рамках одной сессии, и почему `architecture.md` должен связывать DI-компоненты (Core, Net, Rtc, Env) именно с этим непрерывным состоянием.
- Сервер сохраняет только кратковременное техническое состояние (sessionId, опциональные WebPush-метаданные) — никаких пользователей/профилей. Описание `arch/back.md`, `arch/env/*.md`, `node/bin/server.md` и `arch/env/logrotate.md` подчёркивает именно эту автономность, чтобы новые привязки между зеро-экраном и backend оставались прозрачными.

## Связь архитектуры и окружений

Архитектура определяет логическую структуру и роли компонентов Связист. Документы `./arch/env/apache.md` и `./arch/env/node.md` конкретизируют инфраструктурные параметры развёртывания для каждого уровня окружения, сохраняя связь с этим архитектурным описанием. Дополнительная детализация зафиксирована в `./arch/linkage.md`.

## Конфигурация окружения

Все сетевые и системные параметры backend-приложения передаются через файл `.env`, описанный в документе `./arch/env/config.md`.  
Этот механизм обеспечивает согласованность между архитектурными декларациями и фактическим окружением Node.js и Apache.  
Параметры (`PORT`, `WS_PORT`, `HOST_PUBLIC`, `NODE_ENV`) определяют доступность API, канал сигналинга и внешний адрес приложения.

## Версионирование и обновления

- Каждая сборка PWA имеет уникальный номер версии, отражённый в манифесте.
- Сервер при каждом запросе отдаёт актуальную версию кода.
- Сервис-воркер на клиенте автоматически обновляет локальную копию при обнаружении новой версии.

## Ссылки

- `./arch/env/apache.md` — окружение Apache.
- `./arch/env/node.md` — окружение Node.js.
- `./arch/linkage.md` — связь архитектуры и окружений.
- `./arch/teqfw.md` — проектные правила TeqFW.
- `./arch/teqfw/di.md` — универсальные принципы DI.
- `./arch/teqfw/module-template.md` — шаблон модулей, используемый при генерации кода.
- `./arch/testing.md` — правила модульного тестирования.
- `./codex.md` — влияние когнитивного слоя на генерацию кода.

## Итог

Минимальная архитектура: одно Node.js-приложение управляет раздачей, хранением переменных данных и механизмом обновления PWA без внешних зависимостей, опираясь на контейнер `@teqfw/di` для согласованного управления компонентами.
