# Frontend Связист — модульный монолит (`ctx/rules/arch/front.md`)

## Назначение

Документ описывает фронтенд Связист как модульный монолит, в котором логические контуры сгруппированы вокруг контейнера зависимостей `@teqfw/di`.  
Каждая область разворачивается как функциональный контур, взаимодействующий с соседями через события и коллбэки, при этом диаграмма остаётся «мелкой картой» верхнего уровня: Core связывает контуры, Shared снабжает инфраструктурой, а остальные решают пользовательские и медиапроцессы.

> **Согласованность с продуктом:** `ctx/product/overview.md`, `ctx/product/capabilities/connection.md` и `ctx/product/capabilities/link-sharing.md` описывают единое окно связи с состояниями `ready`, `waiting`, `active`, в котором ссылка создаётся внутри текущего сеанса. Сейчас фронтенд представлен как последовательность экранов `home → invite → call → end`, потому что именно эти названия использует `web/app/State/Machine.mjs` и `web/app/Ui/ScreenFactory.mjs`. В будущем все упоминания экранов будут заменены на состояния одного окна, см. план `ctx/agent/plan/2025/11/20251129-rules-implementation-fixes.md`.

## Обзор модульного монолита

- Frontend собирается как один SPA-пакет, но логика разграничена по функциональным контурам.
- Все объекты контура разрешаются через DI-контейнер, поэтому код не импортирует напрямую модули других областей.
- Сборка приложения и тестов происходит через позднее связывание зависимостей: Core и тесты получают нужные реализации при старте, агенты (включая LLM-агенты) формируют среду без ручной сваггер-инициализации.
- Core остаётся единственной точкой оркестрации, остальные контуры слушают события и прокидывают коллбэки внутри своих границ.

## Контуры фронтенда и их назначение

| Контур | Назначение | Интерфейсные связи | Типичные DI-зависимости |
| --- | --- | --- | --- |
| **Core** | Оркестрация жизненного цикла приложения, маршрутизация состояний и экранов, делегирование задач в другие контуры | вызывает коллбэки и команды, зарегистрированные через DI, чтобы обновить UI и медиа | `HomeCall_Web_Core_App$`, `HomeCall_Web_Core_StateMachine$` |
| **Env** | Абстракция окружения (браузерные переменные, флаги, настройка `Env.Provider`, секреты из `.env`) | предоставляет контракты для `Core`, `Media`, `Net`, `Shared.Logger` | `HomeCall_Web_Env_Provider$`, `HomeCall_Web_Env_Adapter$` |
| **Ui** | Экраны PWA, управление переходами и отображением состояний из Core | получает прямые команды от Core и другие контуры, обновляет DOM без промежуточных шин | `HomeCall_Web_Ui_ScreenFactory$`, `HomeCall_Web_Ui_Renderer$` |
| **Media** | Менеджер устройств (камера, микрофон), микширование потоков и оповещение об их состоянии | выполняет коллбэки устройств и сообщает Core/Rtc через DI-интерфейсы | `HomeCall_Web_Media_DeviceManager$`, `HomeCall_Web_Media_SignalRouter$` |
| **Rtc** | Создание и поддержка `RTCPeerConnection`, управление SDP/ICE и жизненным циклом соединений | интегрируется с Net и Core по DI-интерфейсам, делясь состоянием соединения | `HomeCall_Web_Rtc_Peer$`, `HomeCall_Web_Rtc_PeerFactory$` |
| **Net** | Каналы сигналинга (`WebSocket`), маршрутизация событий между клиентами и сервером, управление статусом сети | принимает команды от Core и передаёт сигналы Rtc через зарегистрированные callback-интерфейсы | `HomeCall_Web_Net_SignalClient$`, `HomeCall_Web_Net_EventTranslator$` |
| **Shared** | Общая инфраструктура: логгер, утилиты, хранилище локального состояния | предоставляет сервисы через DI (logger, util, event translator) | `HomeCall_Web_Shared_Logger$`, `HomeCall_Web_Shared_Util$` |

Поскольку контуры не импортируют друг друга напрямую, таблица фиксирует выходы и входы, доступные через DI-интерфейсы и общие сервисы `Shared`.

## Механизм взаимодействия областей

1. **Внутри контура** — объекты общаются через методы и коллбэки: Core вызывает `VersionWatcher.start()`, Ui сообщает Core о нажатиях, Media отдаёт события `devicechange`.
2. **Между контурами** — обмен идёт через DI-коллбэки и общий `Shared` сервис; Core вызывает Media, Net и Ui напрямую, и эти контуры используют зарегистрированные callback-интерфейсы для обратной связи.
3. **Core** — единственная точка оркестрации: при смене состояния вызывает экран (`Ui`), запрашивает окружение (`Env`) и настраивает медиапотоки (`Media`/`Rtc`), прокидывает направления в `Net`.
4. **Shared** — общая инфраструктура (`Logger`, `Util`, `SignalTranslator`), доступная всем контурам через контейнер; события и состояния передаются через коллбэки, а не через глобальную шину.
5. **Контейнер `@teqfw/di`** обеспечивает позднее связывание и гарантии, что только зарегистрированные зависимости доступны каждой области.

## Контейнер зависимостей и позднее связывание

1. Все модули Связист разрешаются через `@teqfw/di` внутри шаблонов `HomeCall_Web_<Контур>_<Модуль>$`.
2. Позднее связывание используется при запуске (браузер запрашивает зарегистрированные экземпляры), при тестах (подменяют `Env.Provider` и внимательной настройкой DI-моков) и при проверках LLM-агентов (Codex-агент собирает среду с теми же регистрациями, что и браузер).
3. Контейнер фиксирует контурные границы: каждый контур видит только свои зависимости и общие сервисы (`Shared`), прямой импорт запрещён.
4. Документ служит обзорной картой: для деталей см. `ctx/rules/web/{core,env,ui,media,rtc,net,shared}.md`.

## Связи

- `ctx/rules/architecture.md` — общее архитектурное пространство и принципы управления зависимостями.
- `ctx/rules/web/ui/screens.md` — экранная логика `Ui`.
- `ctx/rules/web/*` — конкретные описания контуров и их публичных интерфейсов.
