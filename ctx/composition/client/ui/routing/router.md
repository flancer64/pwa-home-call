# Принципы работы и механика Router

Path: `./ctx/composition/client/ui/routing/router.md`

## Принципы работы маршрутизатора

1. **URL → маршрут → экран.** Router получает hash-часть URL, преобразует её в логическое имя экрана и параметры, формирует структуру обращения к шаблону и контроллеру.
2. **Hash-based routing.** Используется формат `#/screen-name` или `#/screen-name/param`. Навигация выполняется полностью на клиенте и не требует изменения серверной конфигурации.
3. **Загрузка шаблона по имени экрана.** Для каждого маршрута Router вызывает загрузчик HTML-шаблона, предоставляющего основу для компонентов экрана.
4. **Создание экземпляра контроллера экрана.** Router передаёт параметры маршрута и зависимости контроллеру, который связывает шаблон с поведением и логикой взаимодействия.
5. **Управление жизненным циклом экрана.** Router размонтирует предыдущий экран, инициализирует и монтирует новый, передаёт управление контроллеру и поддерживает один активный экран.
6. **Интеграция с UI Flow.** Router управляет навигацией, а Flow определяет бизнес-логику звонка и состояния. Между ними действует чёткое разделение обязанностей.
7. **Изоляция подсистем.** Router не имеет зависимостей от WebRTC, Signal, Media или других окружений и работает только с UI-модулями.

## Fallback-маршрут и экран `not-found`

Router обязан обеспечивать определённое поведение при обращении к несуществующим маршрутам. Для этого вводится fallback-маршрут, направляющий на экран `not-found`.

### Назначение fallback-маршрута

- обеспечить корректную визуальную реакцию при недействительных или неизвестных URL;
- исключить появление пустого состояния или частично инициализированного экрана;
- поддержать предсказуемую композицию UI при расширении набора маршрутов.

### Требования к реализации

1. Если маршрут не совпадает с таблицей известных экранов, Router инициирует переход на экран `not-found`.
2. Экран `not-found` является автономным шаблоном и не участвует в состоянии звонка.
3. Fallback-маршрут не изменяет состояние Flow и не влияет на внутренние процессы приложения.
4. Router гарантирует наличие одного активного экрана, включая случаи некорректного URL.

### Гарантии Router

- Любой URL приводит к отображению конкретного экрана.
- Невалидные маршруты не создают неопределённых состояний UI.
- Fallback-экран обеспечивает устойчивость навигации и согласованность подсистем.

## Архитектурная модель Router

- **Router** — навигационный уровень, связывающий URL с экранами.
- **TemplatesLoader** — уровень доступа к HTML-шаблонам экранов.
- **ScreenController** — уровень поведения экрана, принимающего параметры и формирующего набор событий.
- **Flow** — уровень бизнес-логики звонка и состояний.

Router связывает только UI-подсистемы и передаёт управление экранам, взаимодействующим с Flow.

## Интерфейс Router (декларативный)

- `init()` — привязка обработчиков `hashchange` и выполнение первичной загрузки маршрута.
- `resolve(url)` — разбор маршрута из hash-части URL и выделение параметров.
- `navigate(route)` — смена экрана с учётом структуры маршрута.
- `mountScreen(screen, params)` — загрузка шаблона и монтирование экрана с передачей параметров.
- `unmountScreen()` — очистка текущего экрана и освобождение ресурсов.
