# Обзор подсистемы Router

Path: `./ctx/composition/client/ui/routing/overview.md`

## Назначение Router

Router представляет собой навигационный слой клиентского UI, который работает с одним и тем же API маршрутов независимо от того, какие экраны реализованы в проекте. Router получает маршруты через Dependency Injection и на их основе решает, какой шаблон, контроллер и параметры использовать для отображения следующего состояния UI. Он не содержит ссылок на конкретные экраны, шаблоны или контроллеры, а лишь гарантирует, что навигация останется предсказуемой при смене конфигурации.

## Как Router потребляет конфигурацию маршрутов

- Router принимает `routeConfig: { [name]: { template, controllerFactory } }` и `defaultParams: { [name]: Record<string, unknown> }` через DI-модуль композиции.
- Каждая запись `routeConfig` описывает, какой шаблон рендерится и какую фабрику контроллера следует вызвать, чтобы получить экземпляр для нового экрана.
- `defaultParams` дополняет параметры, передаваемые контроллеру, когда маршрут не задаёт их явно. Router не хранит параметры по умолчанию внутри себя и не усложняет структуру конфигурации.
- Конкретные маршруты, их имена, шаблоны и фабрики объявлены в `routes.md`; Router опирается на них, но не зависит от них при расширении набора экранов.

## Механика сброса и fallback

Router анализирует hash-часть URL, сопоставляет имя маршрута с конфигурацией и вызывает фабрику контроллера. Конфигурационный модуль предоставляет Router текущее `routeConfig`, `defaultParams` и методы `registerRoute`/`setDefaultParams`, благодаря чему приложение (Flow, bootstrap и другие модули) может инкрементно добавлять маршруты и подставлять реальные обработчики. Если hash не соответствует ни одной записи, Router переключается на объявленный в конфигурации fallback-маршрут (описание конфигурации посадки fallback-элемента находится в `routes.md`), например `not-found`, который всегда перебрасывает браузер на `/`. Устойчивость навигации достигается за счёт конфигурации, а не добавления экранов в сам Router.

## Взаимодействие с другими подсистемами UI

- **TemplatesLoader** предоставляет шаблоны, упомянутые в `routeConfig`, и Router вызывает его только по имени маршрута.
- **ControllerFactory** (DI) создаёт контроллеры на каждую навигацию; Router передаёт фабрике параметры марштрута и помещает возвращённый экземпляр в DOM.
- **Flow и StateMachine** управляют бизнес-состояниями, но Router изолирован от них: он только отображает маршруты, заданные во внешней конфигурации.
- **Layouts и UI-компоненты** подключаются к Router через шаблоны и контроллеры; сами они и их зависимости описаны вне этой подсистемы.

## Границы ответственности

Router обеспечивает стабильный API навигации при сохранении независимости от состава экранов: оно не содержит связей с сервисами, не принимает решения о сценариях звонка и не инициирует их. Любое изменение экрана происходит только в конфигурации маршрутов, а не в Router.
